package p3.round_robin;

import java.util.LinkedList;

/**
 * This class implements functionality associated with
 * the CPU unit of the simulated system.
 */
public class Cpu {
    /**
     * Creates a new CPU with the given parameters.
     * @param cpuQueue		The CPU queue to be used.
     * @param maxCpuTime	The Round Robin time quant to be used.
     * @param statistics	A reference to the statistics collector.
     */

    private LinkedList<Process> cpuQueue;
    private long maxCpuTime;
    private Statistics statistics;
    private Process activeProcess = null;

    public Cpu(LinkedList<Process> cpuQueue, long maxCpuTime, Statistics statistics) {
        this.cpuQueue = cpuQueue;
        this.maxCpuTime = maxCpuTime;
        this.statistics = statistics;

        // Incomplete
    }

    /**
     * Adds a process to the CPU queue, and activates (switches in) the first process
     * in the CPU queue if the CPU is idle.
     * @param p		The process to be added to the CPU queue.
     * @param clock	The global time.
     * @return		The event causing the process that was activated to leave the CPU,
     *				or null	if no process was activated.
     */
    public Event insertProcess(Process p, long clock) {
        cpuQueue.addLast(p);
        //System.out.println("Added " + p.getProcessId() + " to CPU queue");
        //if CPU is idle
        if(activeProcess == null){
            //System.out.println("CPU is idle, so we activate " + p.toString());
            return switchProcess(clock);
        }
        return null;
    }

    /**
     * Activates (switches in) the first process in the CPU queue, if the queue is non-empty.
     * The process that was using the CPU, if any, is switched out and added to the back of
     * the CPU queue, in accordance with the Round Robin algorithm.
     * @param clock	The global time.
     * @return		The event causing the process that was activated to leave the CPU,
     *				or null	if no process was activated.
     */
    public Event switchProcess(long clock) {
        Event event;

        if(!cpuQueue.isEmpty()){
            activeProcess = cpuQueue.removeFirst();
            System.out.println(activeProcess.getProcessId() + " is in CPU " + activeProcess.getCpuTimeNeededLeft() +
                    " " + activeProcess.getTimeToNextIoOperation());
            event = getNextEvent(clock);
        }else{
            activeProcess = null;
            return null;
        }

        //place the previously active process in the queue if it isn't done
        if((event.getType() == Event.SWITCH_PROCESS)){
            cpuQueue.addLast(activeProcess);
        }
        activeProcess.updateStatistics(statistics);
        return event;

        // Incomplete
    }

    /**
     * Called when the active process left the CPU (for example to perform I/O),
     * and a new process needs to be switched in.
     * @return	The event generated by the process switch, or null if no new
     *			process was switched in.
     */
    public Event activeProcessLeft(long clock) {
        //incomplete
        activeProcess = null;
        return switchProcess(clock);
    }

    /**
     * Returns the process currently using the CPU.
     * @return	The process currently using the CPU.
     */
    public Process getActiveProcess() {
        return activeProcess;
    }

    /**
     * This method is called when a discrete amount of time has passed.
     * @param timePassed	The amount of time that has passed since the last call to this method.
     */
    public void timePassed(long timePassed) {
        statistics.cpuQueueLengthTime += cpuQueue.size()*timePassed;
        if (cpuQueue.size() > statistics.cpuQueueLargestLength) {
            statistics.cpuQueueLargestLength = cpuQueue.size();
        }
    }

    private Event getNextEvent(long clock){
        int eventType = Event.SWITCH_PROCESS;
        long runTime = maxCpuTime;
        long remainingTime = activeProcess.getCpuTimeNeededLeft();
        long timeToIo = activeProcess.getTimeToNextIoOperation();

        //compare all the times to next events and take the shortest
        if(remainingTime < runTime){
            //run for remaining time
            runTime = remainingTime;
            eventType = Event.END_PROCESS;
        }else if(timeToIo < runTime) {
            //run until IO
            runTime = timeToIo;
            eventType = Event.IO_REQUEST;
        }

        statistics.totalTimeSpentInCpu += runTime;
        statistics.totalBusyCpuTime += runTime;
        activeProcess.activate(runTime);
        return new Event(eventType, clock + runTime);
    }

}
